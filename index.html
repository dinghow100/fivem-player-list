<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FiveM Global Player Finder</title>
  <style>
    :root {
      --bg: #0b0e13;
      --muted: #9aa4b2;
      --card: #11161f;
      --fg: #e6edf3;
      --accent: #7aa2ff;
      --accent-2: #2dd4bf;
      --warn: #f59e0b;
      --danger: #ef4444;
      --border: #1f2a37;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 80% -10%, #0f172a 0%, var(--bg) 40%) no-repeat fixed;
      color: var(--fg);
    }
    header { padding: 24px 16px 8px; text-align: center; }
    h1 { margin: 0 0 6px; font-size: clamp(22px, 3vw, 28px); letter-spacing: .2px; }
    p.sub { margin: 0; color: var(--muted); font-size: 13px; }

    .card { max-width: 1200px; margin: 18px auto; background: color-mix(in oklab, var(--card), black 4%); border: 1px solid var(--border); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .card .content { padding: 16px; }

    form#searchForm { display: grid; grid-template-columns: 1fr auto auto; gap: 10px; align-items: center; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    input[type="text"] { width: 100%; padding: 12px 14px; border-radius: 12px; border: 1px solid var(--border); background: #0b1220; color: var(--fg); outline: none; }
    input[type="text"]::placeholder { color: #758195; }
    .btn { padding: 10px 14px; border-radius: 12px; border: 1px solid var(--border); background: #0e1524; color: var(--fg); cursor: pointer; }
    .btn.primary { background: linear-gradient(180deg, var(--accent), #5b87ff); border: none; color: white; }
    .btn.ghost { background: transparent; }
    .btn:disabled { opacity: .6; cursor: not-allowed; }

    .chips { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; color: var(--muted); font-size: 13px; }
    .chip { display: inline-flex; gap: 8px; align-items: center; border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; background: #0b1220; }
    .chip input { transform: translateY(1px); }

    #status { margin-top: 10px; font-size: 13px; color: var(--muted); }

    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    thead { position: sticky; top: 0; z-index: 2; background: #0c1220; box-shadow: 0 1px 0 var(--border); }
    th, td { padding: 10px 12px; border-bottom: 1px solid var(--border); text-align: left; font-size: 14px; }
    tbody tr:nth-child(odd) { background: #0a101b; }
    code { background: #0b1220; padding: 2px 6px; border-radius: 8px; border: 1px solid var(--border); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 3px 8px; border-radius: 999px; border: 1px solid var(--border); background: #0a1220; font-size: 12px; color: var(--muted); }
    .badge .dot { width: 8px; height: 8px; border-radius: 50%; }

    .hint { font-size: 12px; color: var(--muted); margin-top: 8px; }
    .warn { color: var(--warn); }
    .danger { color: var(--danger); }
    a { color: var(--accent-2); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <h1>FiveM Global Player Finder</h1>
    <p class="sub">Search a player name across the live CFX masterlist and see which server they’re on. Results appear as they’re found.</p>
  </header>

  <section class="card">
    <div class="content">
      <form id="searchForm" autocomplete="off">
        <input id="name" type="text" placeholder="Type a player name (e.g. matthew)" />
        <button class="btn primary" type="submit" id="goBtn">Search</button>
        <button class="btn ghost" type="button" id="stopBtn" disabled>Stop</button>
        <div class="chips" style="grid-column: 1 / -1;">
          <label class="chip"><input id="exact" type="checkbox" /> Exact match</label>
          <label class="chip"><input id="highlight" type="checkbox" checked /> Highlight matches</label>
          <span class="chip" title="The stream is large; this keeps memory sane."><input id="cap" type="checkbox" checked /> Cap results at 1500</span>
          <span class="chip"><span class="dot" id="led" style="background:#64748b"></span><span id="stateText">Idle</span></span>
        </div>
        <div id="status">Idle.</div>
      </form>

      <div class="hint">Tip: This uses the official <code>servers-frontend.fivem.net</code> stream. If your browser shows a CORS error, open this file via a local web server (e.g. <code>npx serve</code>) and try again.</div>

      <table id="results">
        <thead>
          <tr>
            <th>Player</th>
            <th>Server</th>
            <th>Server ID</th>
            <th>Players</th>
            <th>Join</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <script>
    const STREAM_CANDIDATES = [
      // If you host a Cloudflare Worker proxy, put it first:
      // e.g. "https://YOUR_WORKER_SUBDOMAIN.workers.dev/stream",
      // Local proxy (for testing):
      "http://127.0.0.1:8787/stream",
      "http://localhost:8787/stream",
      // Direct public streams (may be blocked by CORS in some browsers / on GitHub Pages)
      "https://servers-frontend.fivem.net/api/servers/stream",
      () => `https://servers-frontend.fivem.net/api/servers/stream/${Math.floor(Date.now()/1000)}`
    ];

    const DETAIL_URL = (id) => `https://servers.fivem.net/servers/detail/${id}`;
    const JOIN_URL = (id) => `https://cfx.re/join/${id}`;

    let controller = null;
    let stopFlag = false;
    let resultCount = 0;

    const nameEl = document.getElementById('name');
    const exactEl = document.getElementById('exact');
    const capEl = document.getElementById('cap');
    const highlightEl = document.getElementById('highlight');
    const statusEl = document.getElementById('status');
    const ledEl = document.getElementById('led');
    const stateTextEl = document.getElementById('stateText');
    const tbody = document.querySelector('#results tbody');

    document.getElementById('searchForm').addEventListener('submit', (e) => {
      e.preventDefault();
      const query = nameEl.value.trim();
      if (!query) { alert('Enter a player name'); return; }
      tbody.innerHTML = '';
      resultCount = 0;
      stopFlag = false;
      setState('Connecting…', '#7aa2ff');
      document.getElementById('stopBtn').disabled = false;
      runWithFallback(query, exactEl.checked).catch((err) => {
        setState('Error', '#ef4444');
        statusEl.innerHTML = `Error: ${escapeHtml(err.message || err)}. <span class="hint">On GitHub Pages you likely need a proxy (see README). Add your proxy URL at the top of <code>STREAM_CANDIDATES</code>.</span>`;
        console.error(err);
      }).finally(() => {
        document.getElementById('stopBtn').disabled = true;
      });
    });

    document.getElementById('stopBtn').addEventListener('click', () => {
      stopFlag = true;
      if (controller) controller.abort();
      setState('Stopped', '#f59e0b');
    });

    function setState(text, color) {
      stateTextEl.textContent = text;
      ledEl.style.background = color;
    }

    async function runWithFallback(query, exact) {
      let lastErr;
      for (const cand of STREAM_CANDIDATES) {
        const url = typeof cand === 'function' ? cand() : cand;
        try {
          await runSearch(url, query, exact);
          return;
        } catch (e) {
          lastErr = e;
          if (stopFlag) break;
          console.warn('Stream candidate failed:', url, e);
        }
      }
      throw lastErr || new Error('No working stream endpoint.');
    }

    // Robust SSE reader: handles multi-line data: events
    async function runSearch(url, query, exact) {
      setState('Scanning…', '#2dd4bf');

      const ac = new AbortController();
      controller = ac;
      const res = await fetch(url, {
        method: 'GET',
        signal: ac.signal,
        headers: { 'Accept': 'text/event-stream' },
        cache: 'no-store',
        mode: 'cors'
      });
      if (!res.ok || !res.body) throw new Error(`Stream not available (${res.status})`);

      const reader = res.body.getReader();
      const decoder = new TextDecoder('utf-8');

      let serversScanned = 0, matchesFound = 0;
      const q = normalize(query);

      const flushBatch = (rows) => {
        const frag = document.createDocumentFragment();
        rows.forEach((tr) => frag.appendChild(tr));
        tbody.appendChild(frag);
      };
      let batch = [];

      // SSE state
      let sseBuf = '';
      let dataBuf = '';

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        sseBuf += decoder.decode(value, { stream: true });

        // split by lines and process SSE frames
        let idx;
        while ((idx = sseBuf.indexOf('
')) !== -1) {
          const line = sseBuf.slice(0, idx).replace(/
$/, '');
          sseBuf = sseBuf.slice(idx + 1);

          if (line.startsWith('data:')) {
            dataBuf += line.slice(5).trim();
          } else if (line === '') {
            if (dataBuf) {
              try {
                const obj = JSON.parse(dataBuf);
                serversScanned++;
                handleServer(obj, q, exact, batch, () => { matchesFound++; });
                if (serversScanned % 200 === 0 || batch.length >= 50) {
                  statusEl.textContent = `Servers scanned: ${serversScanned.toLocaleString()} • Matches: ${matchesFound.toLocaleString()}`;
                  if (batch.length) { flushBatch(batch); batch = []; }
                }
              } catch (e) {
                // ignore malformed frame
              }
            }
            dataBuf = '';
          }
        }

        if (stopFlag) break;
      }

      if (batch.length) flushBatch(batch);
      setState('Done', '#22c55e');
      statusEl.textContent = `Servers scanned: ${serversScanned.toLocaleString()} • Matches: ${matchesFound.toLocaleString()}`;
    }

    function handleServer(obj, q, exact, batch, onMatch) {
      const id = obj.EndPoint || obj.endpoint || obj.ID || obj.id;
      const data = obj.Data || obj.data || {};
      const hostname = stripFxColors(String(data.hostname || ''));
      const clients = data.clients ?? 0;
      const players = Array.isArray(data.players) ? data.players : [];

      const found = players.filter((p) => matchName(p && p.name, q, exact));
      if (found.length) {
        for (const p of found) {
          if (capEl.checked && resultCount >= 1500) break;
          const tr = document.createElement('tr');
          const playerName = String(p && p.name ? p.name : '(unknown)');
          tr.innerHTML = `
            <td>${formatName(playerName, q)}</td>
            <td>${escapeHtml(hostname)}</td>
            <td><code>${escapeHtml(id || '')}</code></td>
            <td>${Number(clients) || 0}</td>
            <td><a href="${JOIN_URL(id)}" target="_blank" rel="noopener">Join</a></td>
            <td><a href="${DETAIL_URL(id)}" target="_blank" rel="noopener">Details</a></td>`;
          batch.push(tr);
          onMatch(); resultCount++;
        }
      }
    }

    function matchName(candidate, q, exact) {
      if (typeof candidate !== 'string') return false;
      const c = normalize(candidate);
      return exact ? c === q : c.includes(q);
    }

    function normalize(s) {
      return stripFxColors(String(s)).toLowerCase();
    }

    function stripFxColors(s) {
      // remove ^0-^9 color codes
      return s.replace(/\^[0-9]/g, '');
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (c) => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
      })[c]);
    }

    function formatName(name, q) {
      const clean = stripFxColors(String(name));
      if (!highlightEl.checked) return escapeHtml(clean);
      const idx = clean.toLowerCase().indexOf(q);
      if (idx === -1) return escapeHtml(clean);
      const before = escapeHtml(clean.slice(0, idx));
      const mid = escapeHtml(clean.slice(idx, idx + q.length));
      const after = escapeHtml(clean.slice(idx + q.length));
      return `${before}<mark style="background:#3b82f6; color:white; padding:1px 4px; border-radius:6px;">${mid}</mark>${after}`;
    }
  </script>
</body>
</html>
